/** 
 * A skill implementing KB_Prolog via JPL framework https://jpl7.org/
 * 
 * @author Sebastian Sardina (ssardina@gmail.com)
 */
package io.sarl.extras

import io.sarl.core.Logging
import io.sarl.lang.core.Capacity

import io.mochalog.bridge.prolog.PrologContext
import io.mochalog.bridge.prolog.SandboxedPrologContext
import io.mochalog.bridge.prolog.query.MQuery
import io.mochalog.bridge.prolog.query.exception.NoSuchSolutionException;
import io.mochalog.bridge.prolog.query.collectors.MQuerySolutionCollector
import io.mochalog.bridge.prolog.query.MQuerySolution
import io.mochalog.bridge.prolog.query.MQuerySolutionIterator
import io.mochalog.bridge.prolog.query.MQuerySolutionList

import org.jpl7.Term

import java.util.Collection
import java.util.Map
import java.util.HashMap
import java.util.ArrayList
import java.util.Iterator
import java.util.Date

import java.io.File
import java.text.SimpleDateFormat
import java.nio.file.Paths
import org.jpl7.Query
import org.jpl7.Util

// /////////////////////////////////////////////////////////////////////////////////////////
// /////////////////////////////////////////////////////////////////////////////////////////
skill JPL_KB_Prolog implements KB_Prolog {
	uses Logging
	
	protected val kb_name : String

	val prolog : PrologContext // Interface to SWI-Prolog interpreter
	var swi_file : String

	// All data for the directory where KB will be dump
	val formatter = new SimpleDateFormat("yyyy-MM-dd--HH-mm-ss")
	val runtime_timestamp = formatter.format(new Date()) // store runtime date time as a string
	var kb_dump_root_dir : String
	var kb_directory_path_posix : String
	var kb_dump_dir : File

	val module_name : String

	new(name : String, dump_dir : String = "kb_jpl_dump") {
		super() // Call the super's constructor
		kb_name = name
		
		module_name = this.owner.ID.toString;
		
		prolog = new SandboxedPrologContext(this.kb_name)

		set_dump_root(dump_dir)
	}

	private def add_module(query : String) : String {
		return String.format("%s:%s", this.module_name, query)
	}

	@Deprecated
	def consult_file(file : String) {
		val result  = consult(file)
	}

	def consult(file : String) : boolean {
		this.swi_file = file
		
		return Query.hasSolution(add_module(String.format("load_files('%s',[])", file)))
	}

	def set_dump_root(dir : String) {
		kb_dump_root_dir = dir

		// Create if necessary the directory where the KB will be dump for this exec: kb_dump_root_dir/runtime_timestamp/
		kb_dump_dir = new File(kb_dump_root_dir.concat(File.separator).concat(runtime_timestamp))
		if (!kb_dump_dir.exists())
			kb_dump_dir.mkdirs()

		kb_directory_path_posix = String.format("%s/%s", kb_dump_root_dir, runtime_timestamp)
	}

	def dump_kb() {
		dump_kb(kb_name)
	}

	def dump_kb(id : String) {

		//	escape % via double %%
		// F has to be anonymous because JPL cannot return a blob: gives error (so we use _F)
		val timestamp_format = "'%Y-%m-%d--%H-%M-%S'"

		// Format of file to dump: kb_directory_path/
		// val query = String.format("
		// get_time(X),
		// format_time(atom(_T), %s, X, posix),
		// string_concat(\"%s/kb-%s-\", _T,  _BaseNamePosix2),
		// string_concat(_BaseNamePosix2, \"/\",  _BaseNamePosix),
		// string_concat(_BaseNamePosix, \".pl\", _FileNamePosix),
		// prolog_to_os_filename(_FileNamePosix, _FileName),
		// open(_FileName, write, _F), set_output(_F), listing, close(_F)",
		// timestamp_format, kb_directory_path, id)
		val query = String.format("
					prolog_to_os_filename(\"%s/kb-%s-%s.pl\", _FileName),
					open(_FileName, write, _F), set_output(_F), listing, close(_F)", kb_directory_path_posix, id,
			formatter.format(new Date()))

		// When we prove query, we basically execute a listing/0 sending the output to a file with timestamp and id
		if (!Query.hasSolution(query)) {
			error("Dumping the database did not work!")
		}
	}

	def get_kb_name() : String {
		return kb_name
	}

	//	This will yield the Mochalog Prolog object (one can then apply Mochalog methods to it directly!)
	// Not probably the more recommended
	def get_prolog_engine() : PrologContext {
		return prolog
	}

	def assertFirst(queryS : String, params : Object*) {
		prolog.assertFirst(queryS, params)
	}

	def assertLast(queryS : String, params : Object*) {
		prolog.assertLast(queryS, params)
	}

	def retract(queryS : String, params : Object*) {
		prolog.retract(queryS, params)
	}

	def retractAll(queryS : String, params : Object*) {
		prolog.retract(queryS, params)
	}

	//	Prove a query: just return true or false (no variable bindings!)
	// Example:
	def prove(queryS : String, params : Object*) : boolean {
		val termParams = Util.textParamsToTerm()
		params.forEach[]
		return Query.hasSolution(quertyS, termParams)
	}

	// Prove a query just once, but return mapping from variables to terms
	// (Returns null object if no solution is found)
	def askOnce(queryS : String, params : Object*) : Map<String, Term> {
		val query = MQuery.format(queryS, params)
		try {
			val solution = prolog.askForSolution(query)
			return solution.bindings
		} catch (e : NoSuchSolutionException) {
			return null
		}
	}

	// Prove a query and get ALL solutions in a collection of mappings from variables to terms
	// (Returns empty collection if no solution is found)
	def askForAllSolutions(queryS : String, params : Object*) : Collection<Map<String, Term>> {
		val allSolutions : MQuerySolutionList = prolog.askForAllSolutions(queryS, params)

		val colSolutions : Collection<Map<String, Term>> = new ArrayList()
		for (solution : allSolutions) {
			// solution is of type MQuerySolutoin
			colSolutions.add(solution.bindings)
		}
		return colSolutions
	}

	// Prove a query incrementally, by returning an iterator solution object (with a .next method for next solution, if any)
	// (Returns empty collection if no solution is found)
	def ask(queryS : String, params : Object*) : Iterator<MQuerySolution> {
		val query = MQuery.format(queryS, params)
		val solutionIter : Iterator<MQuerySolution> = prolog.askIter(query)
		// val solutionIter : Iterator<MQuerySolution> = new MQuerySolutionIterator(prolog.ask(query))	// manual way of creating an iterator
		return solutionIter
	}

	// Prove a query incrementally, by returning an iterator solution object (with a .next method for next solution, if any)
	// (Returns empty collection if no solution is found)
	def ask2(queryS : String, params : Object*) : Iterator<Map<String, Term>> {
		val query = MQuery.format(queryS, params)
		return new SWI_KB_Prolog_Solution_Iter(prolog.ask(query))
	}

}

/** 
 * This class implements a solution iterator that is able to return bindings directly, not just MQuerySolutions. 
 * In reality, one can just get the Mochalog MQuerySolutionIterator which yields MQuerySolution and then call .bindings 
 */
class SWI_KB_Prolog_Solution_Iter implements Iterator<Map<String, Term>> {
	var solutionIterator : MQuerySolutionIterator
	val outVars : String[]

	new(q : MQuerySolutionCollector, outVars : String[]) {
		this.solutionIterator = new MQuerySolutionIterator(q)
		this.outVars = outVars
	}

	new(q : MQuerySolutionCollector) {
		this.solutionIterator = new MQuerySolutionIterator(q)
		this.outVars = null
	}

	def hasNext : boolean {
		this.solutionIterator.hasNext
	}

	def next : Map<String, Term> {
		if (solutionIterator.hasNext) {
			val solution = solutionIterator.next

			if (outVars === null) {
				return solution.bindings
			} else {
				val bindings2 = new HashMap(solution.bindings)
				bindings2.keySet().retainAll(outVars)
				return bindings2

				// var out : HashMap<String, Term> = new HashMap()
					// for (outVar : outVars) {
				// out.put(outVar, solution.get(outVar))
				// }
					// return out
			}

		} else {
			return null
		}
	}
}
