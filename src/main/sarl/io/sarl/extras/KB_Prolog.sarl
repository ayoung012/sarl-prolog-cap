/** 
 * Prolog knowledge base Capacity/Skill for SARL
 * 
 * Copyright (C) 2018 Sebastian Sardina (ssardina@gmail.com).

 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package io.sarl.extras

import java.nio.file.Paths

// MOCHALOG
// Check https://github.com/ssardina/mochalog/blob/master/subprojects/mochalog-bridge/java-api/src/main/java/io/mochalog/bridge/prolog/PrologContext.java
import io.mochalog.bridge.prolog.PrologContext
import io.mochalog.bridge.prolog.SandboxedPrologContext
import io.mochalog.bridge.prolog.query.Query
import io.mochalog.bridge.prolog.query.exception.NoSuchSolutionException;

import org.jpl7.Term

import java.util.Map
import java.util.HashMap
import io.mochalog.bridge.prolog.query.QuerySolutionList

/** 
 * @author Sebastian Sardina (ssardina@gmail.com)
 * 
 */
capacity KB_Prolog {
	
	/*
	 * Consult a into the Prolog engine
	 * 
	 * @param file the file to be consulted
	 */
	def consult_file(file : String)
	/*
	 * Dump the current KB to file
	 */
	def dump_kb()
	/*
	 * Dump the current KB to file and use id in file name
	 * 
	 * @param id to add to filename
	 */ 
	def dump_kb(id : String)
	/*
	 * Return the handler for the prolog engine
	 */
	def get_prolog_engine()	: Object
	/*
	 * Return name of the KB
	 */
	def get_kb_name() : String

	/*
	 * Assert an unformatted query
	 */
	def assertFirst(queryS : String, params : Object*)

	/* 
	 * Prove an unformatted query
	 */
	def prove(queryS : String, params : Object*) : boolean
	/*
	 * Get the first result of an unformatted query as a Map from variable names to terms
	 */
	def askOnce(queryS : String, outVars : String[], params : Object*) : Map<String, Term>
	/*
	 * Get all the answers for an unformatted query
	 */
	def askForAllSolutions(QueryS : String, params : Object*) : QuerySolutionList

}




skill SWI_KB_Prolog implements KB_Prolog  {
	protected val kb_name : String
	val prolog : PrologContext // Interface to SWI-Prolog interpreter
	var swi_file : String
	
	new(name : String) {
		super() // Call the super's constructor
		kb_name = name
		prolog = new SandboxedPrologContext(this.kb_name)
	}

	def consult_file(file : String) {
		swi_file = file
		
        // Load agent knowledge base
		prolog.importFile(Paths.get(file))
	}

	def dump_kb() {
		dump_kb(kb_name)
	}

	
	def dump_kb(id : String) {
//		prolog.askForSolution(Query.format("save_db(@S)", id))

		//	escape % via double %%
		// F has to be anonymous because JPL cannot return a blob: gives error (so we use _F)
		val query = String.format("
					get_iso_time(_T),
					string_concat(\"kb-%s-\", _T,  _BaseName),
					string_concat(_BaseName, \".pl\", _FileName),
					open(_FileName, write, _F), set_output(_F), listing, close(_F)", id)
		prolog.prove(query)

//		val query = "get_iso_time(T), strings_concat([\"kb-\", @S, \"-\", T, \".pl\"], FileName),
//					open(FileName, write, F), set_output(F), listing, close(F)"
//		prolog.askForSolution(query"save_db(@S)", id)
}
	
	def get_kb_name() {
		return kb_name
	}

	def get_prolog_engine() : PrologContext {
		return prolog
	}

	def assertFirst(queryS : String, params : Object*) {
		prolog.assertFirst(queryS, params)		
	}

//	def buildQuery(queryS : String, params : Object*) {
//		val query = Query.format(queryS, params)
//	}

	def prove(queryS : String, params : Object*) : boolean {
		return prolog.prove(queryS, params)
	}
	
	def askOnce(queryS : String, outVars : String[], params : Object*) : Map<String, Term> {
		val query = Query.format(queryS, params)
		try {
			val solution = prolog.askForSolution(query)
			var out : HashMap<String, Term> = new HashMap()
			for (outVar : outVars) {
				out.put(outVar, solution.get(outVar))
			}
			return out
		} catch (e : NoSuchSolutionException) {
			return null
		} 
	}
	
//	def askOnce(queryS : String, outVars : String[], params : Object*) : Map<String, Term> {
//		val query = Query.format(queryS, params)
//		val solutionCollector = prolog.ask(query)
//		
//		var out : HashMap<String, Term>  = new HashMap()
//		if (solutionCollector.hasSolutions) {
//			for(outVar : outVars) {
//				out.put(outVar, solutionCollector.fetchFirstSolution.get(outVar))
//			}
//			return out			
//		} else {
//			return null
//		}
//	}


	def askForAllSolutions(QueryS : String, params : Object*) : QuerySolutionList {
		return prolog.askForAllSolutions(QueryS, params)
	}	


}