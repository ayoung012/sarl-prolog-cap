/** 
 * Prolog knowledge base Capacity/Skill for SARL
 * 
 * Copyright (C) 2018 Sebastian Sardina (ssardina@gmail.com).

 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package io.sarl.extras

import java.nio.file.Paths

// MOCHALOG
// Check https://github.com/ssardina/mochalog/blob/master/subprojects/mochalog-bridge/java-api/src/main/java/io/mochalog/bridge/prolog/PrologContext.java
import io.mochalog.bridge.prolog.PrologContext
import io.mochalog.bridge.prolog.SandboxedPrologContext
import io.mochalog.bridge.prolog.query.Query
import io.mochalog.bridge.prolog.query.exception.NoSuchSolutionException;

import org.jpl7.Term

import io.mochalog.bridge.prolog.query.collectors.QuerySolutionCollector

import java.util.Collection
import java.util.Map
import java.util.HashMap
import io.mochalog.bridge.prolog.query.QuerySolution
import java.util.ArrayList
import io.mochalog.bridge.prolog.query.QuerySolutionIterator
import java.util.Iterator
import io.mochalog.bridge.prolog.query.QuerySolutionList

import java.io.File

/** 
 * @author Sebastian Sardina (ssardina@gmail.com)
 * 
 */
capacity KB_Prolog {
	
	/*
	 * Consult a into the Prolog engine
	 * 
	 * @param file the file to be consulted
	 */
	def consult_file(file : String)
	/*
	 * Dump the current KB to file
	 */
	def dump_kb()
	/*
	 * Dump the current KB to file and use id in file name
	 * 
	 * @param id to add to filename
	 */ 
	def dump_kb(id : String)
	/*
	 * Return the handler for the prolog engine
	 */
	def get_prolog_engine()	: Object
	/*
	 * Return name of the KB
	 */
	def get_kb_name() : String

	/*
	 * Assert/retract an unformatted query
	 */
	def assertFirst(queryS : String, params : Object*)
	def assertLast(queryS : String, params : Object*)
	def retract(queryS : String, params : Object*)
	def retractAll(queryS : String, params : Object*)

	/* 
	 * Prove an unformatted query
	 */
	def prove(queryS : String, params : Object*) : boolean
	/*
	 * Get the first result of an unformatted query as a Map from variable names to terms
	 */
	def askOnce(queryS : String, params : Object*) : Map<String, Term>

	/*
	 * Get all the answers for an unformatted query as a COllection of mappings vars --> terms
	 */
	def askForAllSolutions(QueryS : String, params : Object*) : Collection<Map<String, Term>>

	/*
	 * Open a new query session in Prolog and returns an object with an iterable 
	 * TODO: this what we would like to have, very generic
	 */
	// def ask(queryS : String, outVars : String[], params : Object*) : Iterator<Map<String, Term>>
	
	/* 
	 * Open a new query session in Prolog and returns an object with an iterable 
	 */
	def ask(queryS : String, params : Object*) : Iterator

	/* 
	 * Open a new query session in Prolog and returns an in-house object with an iterable 
	 */
	def ask2(queryS : String, outVars : String[], params : Object*) : Iterator
}


// /////////////////////////////////////////////////////////////////////////////////////////
// /////////////////////////////////////////////////////////////////////////////////////////
skill SWI_KB_Prolog implements KB_Prolog {
	protected val kb_name : String
	val prolog : PrologContext // Interface to SWI-Prolog interpreter
	var swi_file : String
	
	new(name : String) {
		super() // Call the super's constructor
		kb_name = name
		prolog = new SandboxedPrologContext(this.kb_name)
	}

	def consult_file(file : String) {
		this.swi_file = file
		
        // Load agent knowledge base
		prolog.importFile(Paths.get(file))
	}

	def dump_kb() {
		dump_kb(kb_name)
	} 

	
	def dump_kb(id : String) {

		//	escape % via double %%
		// F has to be anonymous because JPL cannot return a blob: gives error (so we use _F)
		val timestamp_format = "'%Y-%m-%d--%H-%M-%S'"
        val directory_name = "kb_dump_test"
        val path = directory_name.concat(File.separator)

        val directory : File = new File(directory_name)

        if(! directory.exists()) {
            println("DIRECTORY DOES NOT EXIST")
            directory.mkdir()
        }
        else
            println("DIRECTORY ALREADY EXISTS") 

		val query = String.format("
					get_time(X), 
					format_time(atom(_T), %s, X, posix),
					string_concat(\"%skb-%s-\", _T,  _BaseName),
					string_concat(_BaseName, \".pl\", _FileName),
					open(_FileName, write, _F), set_output(_F), listing, close(_F)", timestamp_format, path, id)
	
		// When we prove query, we basically execute a listing/0 sending the output to a file with timestamp and id
		prolog.prove(query)
		// prolog.askForSolution(query"save_db(@S)", id)

		// Another way by calling Mochalog Query.format and an assumed predicate save_db/1
		// prolog.askForSolution(Query.format("save_db(@S)", id))
}
	
	def get_kb_name() : String {
		return kb_name
	}

	//	This will yield the Mochalog Prolog object (one can then apply Mochalog methods to it directly!)
	// Not probably the more recommended
	def get_prolog_engine() : PrologContext {
		return prolog
	}

	def assertFirst(queryS : String, params : Object*) {
		prolog.assertFirst(queryS, params)		
	}

	def assertLast(queryS : String, params : Object*) {
		prolog.assertLast(queryS, params)
	}

	def retract(queryS : String, params : Object*) {
		prolog.retract(queryS, params)
	}

	def retractAll(queryS : String, params : Object*) {
		prolog.retract(queryS, params)
	}

	//	Prove a query: just return true or false (no variable bindings!)
	// Example: 
	def prove(queryS : String, params : Object*) : boolean {
		return prolog.prove(queryS, params)
	}
	
	// Prove a query just once, but return mapping from variables to terms
	// (Returns null object if no solution is found)
	def askOnce(queryS : String, params : Object*) : Map<String, Term> {
		val query = Query.format(queryS, params)
		try {
			val solution = prolog.askForSolution(query)
			return solution.bindings
		} catch (e : NoSuchSolutionException) {
			return null
		} 
	}
	
	// Prove a query and get ALL solutions in a collection of mappings from variables to terms
// (Returns empty collection if no solution is found)
	def askForAllSolutions(queryS : String, params : Object*) : Collection<Map<String, Term>> {
		val allSolutions : QuerySolutionList  = prolog.askForAllSolutions(queryS, params)
		
		val colSolutions : Collection<Map<String, Term>> = new ArrayList()
		for (solution : allSolutions) {
			// solution is of type QuerySolutoin
			colSolutions.add(solution.bindings)
		}
		return colSolutions
	}

	// Prove a query incrementally, by returning an iterator solution object (with a .next method for next solution, if any)
	// (Returns empty collection if no solution is found)
	def ask(queryS : String, params : Object*) : Iterator<QuerySolution> {
		val query = Query.format(queryS, params)
		val solutionIter : Iterator<QuerySolution> = prolog.askIter(query)
		// val solutionIter : Iterator<QuerySolution> = new QuerySolutionIterator(prolog.ask(query))	// manual way of creating an iterator
	
		return solutionIter
	}

	// Prove a query incrementally, by returning an iterator solution object (with a .next method for next solution, if any)
	// (Returns empty collection if no solution is found)
	def ask2(queryS : String, outVars : String[], params : Object*) : Iterator<Map<String,Term>> {
		val query = Query.format(queryS, params)
		return new SWI_KB_Prolog_Solution_Iter(prolog.ask(query), outVars)
	}

}

/** 
 * This class implements a solution iterator that is able to return bindings directly, not just QuerySolutions. 
 * In reality, one can just get the Mochalog QuerySolutionIterator which yields QuerySolution and then call .bindings 
 */
class SWI_KB_Prolog_Solution_Iter implements Iterator<Map<String, Term>> {
	var solutionIterator : QuerySolutionIterator
	val outVars : String[]

	new(q : QuerySolutionCollector, outVars : String[]) {
		this.solutionIterator = new QuerySolutionIterator(q)
		this.outVars = outVars
	}

	new(q : QuerySolutionCollector) {
		this.solutionIterator = new QuerySolutionIterator(q)
		this.outVars = null
	}

	def hasNext : boolean {
		this.solutionIterator.hasNext
	}

	def next : Map<String, Term> {
		if (solutionIterator.hasNext) {
			val solution = solutionIterator.next

			val binding2 = new HashMap(solution.bindings)
			binding2.keySet().retainAll(outVars)
			return binding2
			
//			var out : HashMap<String, Term> = new HashMap()
//			for (outVar : outVars) {
//				out.put(outVar, solution.get(outVar))
//			}
//			return out
		} else {
			return null
		}
	}
}
