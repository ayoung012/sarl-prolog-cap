/** 
 * 
 */
package io.sarl.extras

import io.sarl.core.AgentKilled
import io.sarl.core.AgentSpawned
import io.sarl.core.ContextJoined
import io.sarl.core.ContextLeft
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.MemberJoined
import io.sarl.core.MemberLeft
import io.sarl.core.Lifecycle
import io.mochalog.bridge.prolog.query.QuerySolutionIterator
import java.util.NoSuchElementException
import io.mochalog.bridge.prolog.query.QuerySolution
import java.util.Iterator
import java.util.Map
import org.jpl7.Term

/** 
 * @author ssardina
 * You can test it as follows:
 * 		java -jar target/sarl-prolog-cap-1.3.0.7.2-jar-with-dependencies.jar io.sarl.extras.TestAgt
 */
agent TestAgt {
	uses Logging
	uses KB_Prolog	
	uses Lifecycle
	
	on Initialize {
		// Event trigger before the agent begin to live or to be used.
		// You should put all the initialization statements in this block of code.
		info("The TEST agent was started.")

		setSkill(new SWI_KB_Prolog("test"))

		test_1();
		test_2();
		test_3();
		test_4();
		test_5();
		test_6();

		test_10();	

		
		killMe
	}

	def test_1() {
		val no = 1
		val queryText = "src/test/resources/testKB.pl"
		info("######### Test {0}: consult file ", no, queryText)
		
		consult_file(queryText)
		info("1 - File consulted well")
	}

	def test_2() {
		val no = 2
		val queryText = "test(x) - proving for various x's and asserting"
		info("######### Test {0}: query {1} ", no, queryText)

		if (prove(String.format("test(%s)", 8))) {
				info("2.1 - test(8) proven TRUE well")
		}
		if (!prove(String.format("test(%s)", 3))) {
			info("2.2 - test(3) proven FALSE well")
		}

		assertLast("test(100)")
		info("2.2 - test(100) asserted last well")
	}

	def test_3() {
		val no = 3
		val queryText = "test(X)"
		info("######### Test {0}: query {1} ", no, queryText)

		val solutions = askForAllSolutions(queryText)
		if (!solutions.empty) {
			info("3 - {0} has all solutions as it should:", queryText)
		}
		for (sol : solutions) {
			info(" \t Solution found for {0}: {1}", queryText, sol.get("X").intValue)
		}
	}

	// Iteration
	def test_4() {
		val no = 4
		val queryText = "test_slow(X)"
		info("######### Test {0}: query {1} ", no, queryText)

		//	Ask yields a QuerySolutionIterator (from Mochalog), which is an Iterator<QuerySolution>
		val solutionsIter : Iterator<QuerySolution> = ask(queryText)
		if (solutionsIter.hasNext) {
			info("4.1 - {0} has solution iteration as it should:", queryText)
			while (solutionsIter.hasNext) {
				val solution : QuerySolution = solutionsIter.next()
				info(" \t Solution found for {0}: {1}", queryText, solution.get("X").intValue)
			}
		}
		if (!solutionsIter.hasNext) {
			info("4.2 - {0} does not have more solutions, all good!", queryText)
		}
		try {
			val solutionOne = solutionsIter.next()

		} catch (e : NoSuchElementException) {
			info("4.3 - We tried to get the next query but got exception (good!): {0}", e.message)
		}
	}

	def test_5() {
		val no = 5
		val queryText = "person(X, Y, Z)"
		info("######### Test {0}: query {1} ", no, queryText)
		
		//	Ask yields a QuerySolutionIterator (from Mochalog), which is an Iterator<QuerySolution>
		val solutionsIter : Iterator<QuerySolution> = ask(queryText)
		if (solutionsIter.hasNext) {
			info("5.1 - {0} has solution iteration as it should:", queryText)
			while (solutionsIter.hasNext) {
				val solution : QuerySolution = solutionsIter.next()
				info(" \t Solution found for {0}: {1}", queryText, solution.bindings.toString)
			}
		}
	}

	def test_6() {
		val no = 6
		val queryText = "person(X, Y, Z)"
		info("######### Test {0}: query {1} - just extract Y and Z only", no, queryText)

		//	Ask yields a QuerySolutionIterator (from Mochalog), which is an Iterator<QuerySolution>
		val solutionsIter : Iterator<Map<String,Term>> = ask2(queryText, #["Y","Z"])
		if (solutionsIter.hasNext) {
			info("{0}.1 - {1} has solution iteration as it should:", no, queryText)
			while (solutionsIter.hasNext) {
				val solution : Map<String,Term> = solutionsIter.next()
				info(" \t Solution found for {0}: {1}", queryText, solution.toString)
			}
		}
	}

	def test_10() {
		val no = 10
		val queryText = "listing the database"
		info("######### Test {0}: query {1}", no, queryText)

		dump_kb("test")
		info("{0} - KB dumped!", no)
	}



	
	on Destroy {
		// Event trigger when the agent is destroyed from the system.
		// You should put all the resource releasing statements in this block of code.
		info("The TEST agent was stopped -- ALL TESTS DONE.")
	}

	on AgentSpawned {
		// A new agent has been spawned in our context.
	}

	on AgentKilled {
		// A new agent has been killed in our context.
	}

	on ContextJoined {
		// Event trigger when an agent of the level joins a shared context.
		// Sent to a agent of the same level.
	}

	on ContextLeft {
		// Event trigger when an agent of the level jleaves a shared context.
		// Sent to a agent of the same level.
	}

	on MemberJoined {
		// Event trigger when an agent joins one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}

	on MemberLeft {
		// Event trigger when an agent leaves one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}
}
