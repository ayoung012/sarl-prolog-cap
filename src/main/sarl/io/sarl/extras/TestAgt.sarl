/** 
 * 
 */
package io.sarl.extras

import io.sarl.core.AgentKilled
import io.sarl.core.AgentSpawned
import io.sarl.core.ContextJoined
import io.sarl.core.ContextLeft
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.MemberJoined
import io.sarl.core.MemberLeft
import io.sarl.core.Lifecycle
import java.util.NoSuchElementException
import java.util.Iterator
import java.util.Map
import org.jpl7.Term
import org.jpl7.PrologException
import org.jpl7.Util
import org.jpl7.Query

import io.mochalog.bridge.prolog.query.MQuerySolutionIterator
import io.mochalog.bridge.prolog.query.MQuerySolution


/** 
 * @author ssardina
 * You can test it as follows:
 * 		java -jar target/sarl-prolog-cap-1.3.0.7.2-jar-with-dependencies.jar io.sarl.extras.TestAgt
 */
agent TestAgt {
	uses Logging
	uses KB_Prolog	
	uses Lifecycle

	val testFile = "src/test/resources/testKB.pl"
	
	
	on Initialize {
		// Event trigger before the agent begin to live or to be used.
		// You should put all the initialization statements in this block of code.
		info("The TEST agent was started.")

		setSkill(new SWI_KB_Prolog("test", "my_dump_test"))

		test_1()
		test_2()
		test_3()
		test_4()
		test_5()
		test_6()
		test_7()
		test_8()
		test_9()
		test_10()
		
		
		
		test_100()	

		
		killMe
	}

	def test_1() {
		val no = 1
		val queryText = testFile
		info("######### Test {0}: consult file ", no, queryText)
		
		consult_file(queryText)
		info("1 - File consulted well")
	}

	def test_2() {
		val no = 2
		val queryText = "test(x) - proving for various x's and asserting"
		info("######### Test {0}: query {1} ", no, queryText)

		if (prove(String.format("test(%s)", 8))) {
				info("2.1 - test(8) proven TRUE well")
		} 
		
		if (!prove(String.format("test(%s)", 3))) {
			info("2.2 - test(3) proven FALSE well")
		}

		assertLast("test(@I)", 200)
		info("2.2 - test(100) asserted last well")
		
	}

	def test_3() {
		val no = 3
		val queryText = "test(X)"
		info("######### Test {0}: query {1} ", no, queryText)

		val solutions = askForAllSolutions(queryText)
		if (!solutions.empty) {
			info("3 - {0} has all solutions as it should:", queryText)
		}
		for (sol : solutions) {
			info(" \t Solution found for {0}: {1}", queryText, sol.get("X").intValue)
		}
	}

	// Iteration
	def test_4() {
		val no = 4
		val queryText = "test_slow(X)"
		info("######### Test {0}: query {1} ", no, queryText)

		//	Ask yields a MQuerySolutionIterator (from Mochalog), which is an Iterator<MQuerySolution>
		val solutionsIter : Iterator<MQuerySolution> = ask(queryText)
		while (solutionsIter.hasNext) {
			val solution : MQuerySolution = solutionsIter.next()
			info(" \t Solution found for {0}: {1}", queryText, solution.get("X").intValue)
		}
		if (!solutionsIter.hasNext) {
			info("4.2 - {0} does not have more solutions, all good!", queryText)
		}
		try {
			val solutionOne = solutionsIter.next()

		} catch (e : NoSuchElementException) {
			info("4.3 - We tried to get the next query but got exception (good!): {0}", e.message)
		}
	}

	def test_5() {
		val no = 5
		val queryText = "person(X, Y, Z)"
		info("######### Test {0}: query {1} ", no, queryText)
		
		//	Ask yields a MQuerySolutionIterator (from Mochalog), which is an Iterator<MQuerySolution>
		val solutionsIter : Iterator<MQuerySolution> = ask(queryText)
		if (solutionsIter.hasNext) {
			info("5.1 - {0} has solution iteration as it should:", queryText)
			while (solutionsIter.hasNext) {
				val solution : MQuerySolution = solutionsIter.next()
				info(" \t Solution found for {0}: {1}", queryText, solution.bindings.toString)
			}
		}
	}

	def test_6() {
		val no = 6
		val queryText = "person(X, Y, Z)"
		info("######### Test {0}: query {1} - just extract Y and Z only", no, queryText)

		//	Ask yields a MQuerySolutionIterator (from Mochalog), which is an Iterator<MQuerySolution>
		val solutionsIter : Iterator<Map<String,Term>> = ask2(queryText)
		if (solutionsIter.hasNext) {
			info("{0}.1 - {1} has solution iteration as it should:", no, queryText)
			while (solutionsIter.hasNext) {
				val solution : Map<String,Term> = solutionsIter.next()
				info(" \t Solution found for {0}: {1}", queryText, solution.toString)
			}
		}
	}

	//	Test when a query has no solution or predicate does not even exist!
	def test_7() {
		val no = 7
		var queryText = "current_job(2, Floor, Dir)"
		info("######### Test {0}: failing queries", no, queryText)

		//	Ask yields a MQuerySolutionIterator (from Mochalog), which is an Iterator<MQuerySolution>
		val solution = askOnce(queryText)
		if (solution === null) {
			info(" \t Well done, no solution for query {0}", queryText)
		} else {
			warning(" \t A solution was returned where it should no!!!")
		}

		// this predicate does not work as current_job2/3 does not exist at all
		queryText = "current_job2(2, Floor, Dir)"
		try {
			val solution2 = askOnce(queryText)
			warning(" \t Problem: predicate current_job2/3 does not exist at all but no exception generated by SWI")
		} catch (e : PrologException) {
			info(" \t PrologException caught well! Predicate current_job2/3 does not exist at all. Exception: {0}", e.message)
		}
	}
	
	def test_8() {
		val no = 8
		var queryText = "data(X)"
		info("######### Test {0}: MQuery iterator with different answer types: integer, float, atom, compound", no, queryText)

		//	Ask yields a MQuerySolutionIterator (from Mochalog), which is an Iterator<MQuerySolution>
		val solutionsIter : Iterator<MQuerySolution> = ask(queryText)
		if (solutionsIter.hasNext) {
			info("8.1 - {0} has solution iteration as it should:", queryText)
			while (solutionsIter.hasNext) {
				val solution : MQuerySolution = solutionsIter.next()
				info(" \t Solution found of type {0}", solution.get("X").typeName.toUpperCase)

				if (solution.get("X").integer) {
					info(" \t\t Value as INTEGER: {0}", solution.get("X").intValue)
				}
				if (solution.get("X").float) {
					info(" \t\t Value as FLOAT: {0}", solution.get("X").floatValue)
					info(" \t\t Value as DOUBLE: {0}", solution.get("X").doubleValue)
				}
				if (solution.get("X").atom) {
					info(" \t\t Value of type {0} as String: {1}", solution.get("X").atomType, solution.get("X").toString)
				}
				if (solution.get("X").compound && !solution.get("X").listNil && !solution.get("X").listPair) {
					info(" \t\t Value as COMPOUND TERM of arity {0}: {1}", solution.get("X").arity, solution.get("X").toString)
					for (var i = 0; i < solution.get("X").arity; i++) {
						info(" \t\t\t Term {0} of type {1}: {2}", i,
							solution.get("X").args.get(i).typeName, solution.get("X").args.get(i).toString)
					}
				}
				if (solution.get("X").listNil) {
					info(" \t\t Value as EMPTY LIST: {0}", solution.get("X").toString)
				}
				if (solution.get("X").listPair) {
					val listSolution = solution.get("X").toTermArray.toArray
					info(" \t\t Value as PAIR LIST of length {0}: {1}", Util.listToLength(solution.get("X")), listSolution.toString)
					for (item : listSolution) {
						info(" \t\t\t One member: {0}", item.toString)	
					}
				}
				if (solution.get("X").variable) {
					info(" \t\t Value as VARIABLE: {0}", solution.get("X").toString)
				}
			}
	}
	}

	def test_9() {
		val no = 9
		val queryText = "member(X,[1,2,3,4])"
		info("######### Test {0}: query {1}", no, queryText)
	
		//	Ask yields a MQuerySolutionIterator (from Mochalog), which is an Iterator<MQuerySolution>
//		val solutionsIter : Iterator<MQuerySolution> = ask("member(X,[1,2,3,4])")
		val solutionsIter : Iterator<MQuerySolution> = ask(String.format("member(X, %s)", "[1,2,3,4]"))
		if (solutionsIter.hasNext) {
			info("9.1 - {0} has solution iteration as it should:", queryText)
			while (solutionsIter.hasNext) {
				val solution : MQuerySolution = solutionsIter.next()
				info(" \t Solution found of type {0}: {1}", solution.get("X").typeName.toUpperCase,
					solution.get("X").toString)
			}
		}
	}

	def test_10() {
		val no = 10
		var subno : int
		var queryText = "data_string(\"string\")"
		info("######### Test {0}: query {1}", no, queryText)

		
		subno = 1
		queryText = "data_string(\"string0\")"
		if (prove(queryText)) {
			info("{0}.{1} - Query {2} proven  TRUE correctly!", no, subno, queryText)
		} else {
			error("{0}.{1} - Query {0} proven FALSE wrongly!", no, subno, queryText)
		}
//
//		val x  : String = "string"
////		assertLast("data_string(@S)", x)
////		assertLast(String.format("data_string(\"%s\")", x))
//		assertLast("data_string(\"string\")")
//		info("10.2 - Asserting Last data_string/1: {0}", String.format("data_string(\"%s\")", x))
//
//		if (prove("assertz(data_string(\"string3\"))")) {
//			info("10.3 - proving assertz(data_string(@S))")
//		}
//		
//		
//		if (prove(String.format("data_string(\"%s\")", "string"))) {
//			info("10.4 - data_string(\"string\") proven TRUE well")
//		} else {
//			error("10.4 - FAILED! - data_string(\"string\") proven FALSE wrongly! It should be TRUE!")
//		}
//
//		if (!prove("data_string(string)")) {
//			info("10.5 - data_string(string) proven FALSE well")
//		} else {
//			error("10.5 - FAILED! - data_string(string) proven TRUE wrongly! It should be FALSE!")
//		}
	}
				

	def test_100() {
		val no = 100
		val queryText = "listing the database"
		info("######### Test {0}: query {1}", no, queryText)

		dump_kb("test")
		info("{0} - KB dumped!", no)
		set_dump_root("my_dump_test2")
		dump_kb("again")
		info("{0} - KB dumped AGAIN (in another dir)!", no)
	}



	
	on Destroy {
		// Event trigger when the agent is destroyed from the system.
		// You should put all the resource releasing statements in this block of code.
		info("The TEST agent was stopped -- ALL TESTS DONE.")
	}

	on AgentSpawned {
		// A new agent has been spawned in our context.
	}

	on AgentKilled {
		// A new agent has been killed in our context.
	}

	on ContextJoined {
		// Event trigger when an agent of the level joins a shared context.
		// Sent to a agent of the same level.
	}

	on ContextLeft {
		// Event trigger when an agent of the level jleaves a shared context.
		// Sent to a agent of the same level.
	}

	on MemberJoined {
		// Event trigger when an agent joins one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}

	on MemberLeft {
		// Event trigger when an agent leaves one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}
}
