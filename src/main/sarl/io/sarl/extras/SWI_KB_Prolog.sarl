/** 
 * A skill implementing KB_Prolog via Mochalog framework https://github.com/ssardina/mochalog
 * 
 * @author Sebastian Sardina (ssardina@gmail.com)
 */
package io.sarl.extras

import io.sarl.core.Logging
import io.sarl.lang.core.Capacity

import io.mochalog.bridge.prolog.PrologContext
import io.mochalog.bridge.prolog.SandboxedPrologContext
import io.mochalog.bridge.prolog.query.MQuery
import io.mochalog.bridge.prolog.query.exception.NoSuchSolutionException;
import io.mochalog.bridge.prolog.query.collectors.MQuerySolutionCollector
import io.mochalog.bridge.prolog.query.MQuerySolution
import io.mochalog.bridge.prolog.query.MQuerySolutionIterator
import io.mochalog.bridge.prolog.query.MQuerySolutionList

import org.jpl7.Term

import java.util.Collection
import java.util.Map
import java.util.HashMap
import java.util.ArrayList
import java.util.Iterator
import java.util.Date

import java.io.File
import java.text.SimpleDateFormat
import java.nio.file.Paths

// /////////////////////////////////////////////////////////////////////////////////////////
// /////////////////////////////////////////////////////////////////////////////////////////
skill SWI_KB_Prolog implements KB_Prolog {
	protected val kb_name : String

	val prolog : PrologContext // Interface to SWI-Prolog interpreter
	var swi_file : String

	// All data for the directory where KB will be dump
	val formatter = new SimpleDateFormat("yyyy-MM-dd--HH-mm-ss")
	var kb_directory_path_posix : String 

	new(name : String, kb_dump_dir : String) {
		super() // Call the super's constructor
		kb_name = name
		prolog = new SandboxedPrologContext(this.kb_name)

		if (kb_dump_dir !== null)	set_dump_root(kb_dump_dir)
	}
	
	new(name : String) {
		this(name, null)
		set_dump_root("kb_dump".concat(File.separator).concat(formatter.format(new Date())))
	}
	

	@Deprecated
	def consult_file(file : String) {
		this.swi_file = file

		// Load agent knowledge base
		prolog.importFile(Paths.get(file))
	}

	def consult(file : String) : boolean {
		consult(file)
		return true
	}

	def set_dump_root(kb_dump_dir : String) {
		kb_directory_path_posix = kb_dump_dir

		// if dumping dir does not exist, create it
		val file_kb_directory_path_posix = new File(kb_directory_path_posix)
		if (!file_kb_directory_path_posix.exists())
			file_kb_directory_path_posix.mkdirs()
	}

	def dump_kb() {
		dump_kb(kb_name)
	}

	def dump_kb(id : String) {

		//	escape % via double %%
		// F has to be anonymous because JPL cannot return a blob: gives error (so we use _F)
		val timestamp_format = "'%Y-%m-%d--%H-%M-%S'"

		// Build the query to dump KB (via listing) into dir kb_directory_path_posix
		val query = String.format("
					prolog_to_os_filename(\"%s/kb-%s-%s.pl\", _FileName),
					open(_FileName, write, _F), set_output(_F), listing, close(_F)", kb_directory_path_posix, id,
			formatter.format(new Date()))

		// When we prove query, we basically execute a listing/0 sending the output to a file with timestamp and id
		prolog.prove(query)
	}

	def get_kb_name() : String {
		return kb_name
	}

	//	This will yield the Mochalog Prolog object (one can then apply Mochalog methods to it directly!)
	// Not probably the more recommended
	def get_prolog_engine() : PrologContext {
		return prolog
	}

	def assertFirst(queryS : String, params : Object*) {
		prolog.assertFirst(queryS, params)
	}

	def assertLast(queryS : String, params : Object*) {
		prolog.assertLast(queryS, params)
	}

	def retract(queryS : String, params : Object*) {
		prolog.retract(queryS, params)
	}

	def retractAll(queryS : String, params : Object*) {
		prolog.retract(queryS, params)
	}

	//	Prove a query: just return true or false (no variable bindings!)
	// Example:
	def prove(queryS : String, params : Object*) : boolean {
		return prolog.prove(queryS, params)
	}

	// Prove a query just once, but return mapping from variables to terms
	// (Returns null object if no solution is found)
	def askOnce(queryS : String, params : Object*) : Map<String, Term> {
		val query = MQuery.format(queryS, params)
		try {
			val solution = prolog.askForSolution(query)
			return solution.bindings
		} catch (e : NoSuchSolutionException) {
			return null
		}
	}

	// Prove a query and get ALL solutions in a collection of mappings from variables to terms
	// (Returns empty collection if no solution is found)
	def askForAllSolutions(queryS : String, params : Object*) : Collection<Map<String, Term>> {
		val allSolutions : MQuerySolutionList = prolog.askForAllSolutions(queryS, params)

		val colSolutions : Collection<Map<String, Term>> = new ArrayList()
		for (solution : allSolutions) {
			// solution is of type MQuerySolutoin
			colSolutions.add(solution.bindings)
		}
		return colSolutions
	}
	// Prove a query incrementally, by returning an iterator solution object (with a .next method for next solution, if any)
	// (Returns empty collection if no solution is found)
	def ask(queryS : String, params : Object*) : Iterator<MQuerySolution> {
		val query = MQuery.format(queryS, params)
		val solutionIter : Iterator<MQuerySolution> = prolog.askIter(query)
		// val solutionIter : Iterator<MQuerySolution> = new MQuerySolutionIterator(prolog.ask(query))	// manual way of creating an iterator
		return solutionIter
	}

	// Prove a query incrementally, by returning an iterator solution object (with a .next method for next solution, if any)
	// (Returns empty collection if no solution is found)
	def ask2(queryS : String, params : Object*) : Iterator<Map<String, Term>> {
		val query = MQuery.format(queryS, params)
		return new SWI_KB_Prolog_Solution_Iter(prolog.ask(query))
	}

}

/** 
 * This class implements a solution iterator that is able to return bindings directly, not just MQuerySolutions. 
 * In reality, one can just get the Mochalog MQuerySolutionIterator which yields MQuerySolution and then call .bindings 
 */
class SWI_KB_Prolog_Solution_Iter implements Iterator<Map<String, Term>> {
	var solutionIterator : MQuerySolutionIterator
	val outVars : String[]

	new(q : MQuerySolutionCollector, outVars : String[]) {
		this.solutionIterator = new MQuerySolutionIterator(q)
		this.outVars = outVars
	}

	new(q : MQuerySolutionCollector) {
		this.solutionIterator = new MQuerySolutionIterator(q)
		this.outVars = null
	}

	def hasNext : boolean {
		this.solutionIterator.hasNext
	}

	def next : Map<String, Term> {
		if (solutionIterator.hasNext) {
			val solution = solutionIterator.next

			if (outVars === null) {
				return solution.bindings
			} else {
				val bindings2 = new HashMap(solution.bindings)
				bindings2.keySet().retainAll(outVars)
				return bindings2

				// var out : HashMap<String, Term> = new HashMap()
					// for (outVar : outVars) {
				// out.put(outVar, solution.get(outVar))
				// }
					// return out
			}

		} else {
			return null
		}
	}
}
